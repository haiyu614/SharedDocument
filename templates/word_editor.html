<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ doc.original_name }} - 编辑器</title>
    
    <!-- Base Styles from main app -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- TinyMCE -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tinymce/6.8.2/tinymce.min.js"></script>
    
    <!-- Mammoth.js for docx import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    
    <!-- html-docx-js for export -->
    <script src="https://cdn.jsdelivr.net/npm/file-saver/dist/FileSaver.min.js"></script>
    <script src="https://unpkg.com/html-docx-js/dist/html-docx.js"></script>
    <script>
        // html-docx-js older version exposes htmlDocx global directly.
        // If using a build that exposes htmlDocxJs, map it.
        if (typeof htmlDocx === 'undefined' && typeof htmlDocxJs !== 'undefined') {
            window.htmlDocx = htmlDocxJs;
        }
    </script>
    
    <!-- Socket.IO -->
    <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: 'Inter', sans-serif;
            background: #f3f4f6;
            overflow: hidden;
        }

        /* Header */
        .editor-header {
            height: 50px;
            background: #fff;
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
            z-index: 1000;
        }

        .btn {
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            border: none;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-ghost {
            background: transparent;
            color: #666;
        }
        .btn-ghost:hover {
            background: #f1f1f1;
            color: #333;
        }

        .btn-primary {
            background: #6366f1;
            color: white;
        }
        .btn-primary:hover {
            background: #4f46e5;
        }

        /* Editor Container */
        .editor-container {
            position: absolute;
            top: 50px;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            justify-content: center;
        }

        /* TinyMCE Wrapper to simulate A4 page */
        .document-page {
            width: 210mm;
            min-height: 297mm;
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            margin-bottom: 20px;
        }

        /* TinyMCE Specifics */
        .tox-tinymce {
            border: none !important;
            height: 100% !important;
        }
        
        /* Hide TinyMCE Branding */
        .tox-statusbar__branding { display: none; }
    </style>
</head>
<body>

    <!-- Header -->
    <div class="editor-header">
        <div style="display: flex; align-items: center; gap: 1rem;">
            <a href="{{ url_for('auth.index') }}" class="btn btn-ghost">
                <i class="fas fa-arrow-left"></i> 返回
            </a>
            <div style="font-weight: 600; color: #333; display: flex; align-items: center; gap: 8px;">
                <i class="fas fa-file-word" style="color: #3b82f6;"></i>
                {{ doc.original_name }}
            </div>
        </div>
        <div style="display: flex; align-items: center; gap: 1rem;">
            <span id="status-msg" style="font-size: 0.9rem; color: #666; transition: opacity 0.3s; opacity: 0;"></span>
            <button onclick="saveContent()" class="btn btn-primary">
                <i class="fas fa-save"></i> 保存
            </button>
        </div>
    </div>

    <!-- Main Content -->
    <div class="editor-container">
        <div class="document-page">
            <textarea id="word-editor"></textarea>
        </div>
    </div>

    <script>
        const docId = {{ doc.id }};
        const docName = "{{ doc.original_name }}";
        const fileType = "{{ doc.file_type }}";
        const statusMsg = document.getElementById('status-msg');
        
        const socket = io();
        let isRemoteUpdate = false;
        let editorInstance = null;
        let pendingContent = null;
        
        socket.on('connect', function() {
            socket.emit('join', {room: 'doc_' + docId});
        });
        
        socket.on('update_content', function(data) {
            if (data.type === 'tinymce') {
                const editor = getEditor();
                if (!editor) return;
                const currentContent = editor.getContent();
                if (currentContent !== data.content) {
                    const bookmark = editor.selection.getBookmark(2, true);
                    isRemoteUpdate = true;
                    editor.setContent(data.content || '');
                    try {
                        editor.selection.moveToBookmark(bookmark);
                    } catch(e) {
                        // Bookmark might be invalid if content changed significantly
                    }
                    isRemoteUpdate = false;
                }
            }
        });

        function getEditor() {
            return editorInstance || tinymce.activeEditor || null;
        }

        function setEditorHTML(html) {
            const editor = getEditor();
            if (editor) {
                editor.setContent(html || '');
            } else {
                pendingContent = html || '';
            }
        }

        tinymce.init({
            selector: '#word-editor',
            height: '100%',
            menubar: true,
            plugins: [
                'advlist', 'autolink', 'lists', 'link', 'image', 'charmap', 'preview',
                'anchor', 'searchreplace', 'visualblocks', 'code', 'fullscreen',
                'insertdatetime', 'media', 'table', 'help', 'wordcount'
            ],
            toolbar: 'undo redo | blocks | ' +
                'bold italic backcolor | alignleft aligncenter ' +
                'alignright alignjustify | bullist numlist outdent indent | ' +
                'removeformat | help',
            content_style: 'body { font-family:Helvetica,Arial,sans-serif; font-size:14px; margin: 2rem; }',
            setup: function(editor) {
                editor.on('init', function() {
                    if (pendingContent !== null) {
                        editor.setContent(pendingContent);
                        pendingContent = null;
                    }
                });
                editor.on('input keyup change', function() {
                    if (!isRemoteUpdate) {
                        socket.emit('update_content', {
                            room: 'doc_' + docId,
                            type: 'tinymce',
                            content: editor.getContent()
                        });
                    }
                });
            }
        }).then((editors) => {
            editorInstance = editors[0];
            if (pendingContent !== null) {
                editorInstance.setContent(pendingContent);
                pendingContent = null;
            }
            loadDocumentContent();
        });

        function loadDocumentContent() {
            statusMsg.textContent = 'Loading...';
            statusMsg.style.opacity = '1';
            
            fetch(`/documents/word_content/${docId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('html sidecar not available');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.html) {
                        setEditorHTML(data.html);
                        statusMsg.style.opacity = '0';
                    } else {
                        return fetchBinaryDoc();
                    }
                })
                .catch(err => {
                    console.warn('word_content fallback:', err.message);
                    return fetchBinaryDoc();
                });
        }

        function fetchBinaryDoc() {
            return fetch(`/documents/download/${docId}`)
                .then(response => {
                    if (!response.ok) {
                        if (response.status === 404) {
                             throw new Error('File not found on server');
                        }
                        throw new Error(`Download failed: ${response.status}`);
                    }
                    return response.blob();
                })
                .then(blob => {
                    if (blob.size < 100) {
                         // Double check if it's an error text masquerading as blob
                         // (though we checked response.ok above)
                    }
                    if (fileType === 'docx' || fileType === 'doc') {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const arrayBuffer = event.target.result;
                            mammoth.convertToHtml({arrayBuffer: arrayBuffer})
                                .then(displayResult)
                                .catch(handleError);
                        };
                        reader.readAsArrayBuffer(blob);
                    } else {
                        blob.text().then(text => {
                            setEditorHTML(text);
                            statusMsg.style.opacity = '0';
                        });
                    }
                })
                .catch(err => {
                    console.error(err);
                    statusMsg.textContent = 'Load Error';
                });
        }

        function displayResult(result) {
            setEditorHTML(result.value);
            if(result.messages && result.messages.length > 0) {
                console.log("Mammoth messages:", result.messages);
            }
            statusMsg.style.opacity = '0';
        }

        function handleError(err) {
            console.error(err);
            statusMsg.textContent = '加载失败: ' + err.message;
            statusMsg.style.color = '#ef4444';
            statusMsg.style.opacity = '1';
        }

        async function saveContent() {
            const editor = getEditor();
            if (!editor) {
                alert('Editor not ready yet');
                return;
            }
            statusMsg.textContent = '保存中...';
            statusMsg.style.opacity = '1';
            statusMsg.style.color = '#666';

            try {
                const content = editor.getContent();
                
                const htmlString = `<!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8">
                        <title>${docName}</title>
                    </head>
                    <body>${content}</body>
                    </html>`;
                
                const htmlDocxLib = window.htmlDocx || window.htmlDocxJs || window.htmlDocxjs;
                if (!htmlDocxLib || !htmlDocxLib.asBlob) {
                     throw new Error("Export library not loaded");
                }

                const converted = htmlDocxLib.asBlob(htmlString);
                
                const formData = new FormData();
                formData.append('file', converted, 'edited.docx');
                formData.append('html_content', content);

                const response = await fetch(`/documents/save_blob/${docId}`, {
                    method: 'POST',
                    body: formData
                });
                
                // Handle non-JSON responses (e.g. 401 Unauthorized redirecting to login HTML)
                const contentType = response.headers.get("content-type");
                if (!contentType || !contentType.includes("application/json")) {
                    if (response.status === 401 || response.status === 403) {
                        window.location.href = "{{ url_for('auth.login') }}";
                        return;
                    }
                    throw new Error("Server returned non-JSON response: " + response.status);
                }

                const data = await response.json();
                
                if (data.message) {
                    statusMsg.textContent = '已保存';
                    statusMsg.style.color = '#10b981';
                    setTimeout(() => { statusMsg.style.opacity = '0'; }, 2000);
                } else {
                    throw new Error(data.error);
                }
            } catch (err) {
                console.error(err);
                statusMsg.textContent = '保存失败';
                statusMsg.style.color = '#ef4444';
                alert('保存出错: ' + err.message);
            }
        }
    </script>
</body>
</html>
